# Модели в ASP.NET Core (Web API, Controllers)

## Введение

Когда мы создаём **Web API**, нам нужно как-то принимать данные от клиента и возвращать результат обратно.  
Например: пользователь отправил JSON с данными книги — сервер должен принять эти данные, проверить их и сохранить.  
Для этого в ASP.NET Core есть **модели**.

---

## Что такое модель

**Модель** — это обычный класс в C#, который описывает какие данные мы получаем или отправляем.

```csharp
public class Book
{
    public int Id { get; set; }
    public string Title { get; set; } = default!;
    public string Author { get; set; } = default!;
}
```

---

## Виды моделей

| Вид модели | Для чего используется | Пример |
|-----------------|----------------------|----------|
| **Input DTO** | Данные, которые клиент отправляет на сервер | BookCreateDto |
| **Output DTO** | Данные, которые сервер возвращает клиенту | BookDto |
| **Entity (доменная)** | Данные, которые хранятся в базе | Book |

---

## Привязка данных (Model Binding)

**Model Binding** — это механизм, который автоматически подставляет данные из запроса в параметры вашего метода.

### Пример 1: данные из маршрута

```csharp
[HttpGet("api/books/{id}")]
public IActionResult GetBookById(int id)
{
    return Ok($"Вы запросили книгу с Id = {id}");
}
```

Запрос:
```
GET /api/books/10
```
Результат: `id = 10`

---

### Пример 2: данные из query

```csharp
[HttpGet("api/search")]
public IActionResult SearchBooks(string author)
{
    return Ok($"Вы ищете книги автора: {author}");
}
```

Запрос:
```
GET /api/search?author=Толстой
```

---

### Пример 3: данные из тела (body)

```csharp
[HttpPost("api/books")]
public IActionResult CreateBook([FromBody] BookCreateDto book)
{
    return Ok($"Книга '{book.Title}' создана автором {book.Author}");
}
```

Клиент отправляет:
```json
{
  "title": "Мастер и Маргарита",
  "author": "Булгаков"
}
```

---

## Атрибуты [From...]

| Атрибут | Источник данных | Пример |
|----------|----------------|---------|
| `[FromRoute]` | Из маршрута | `[HttpGet("api/books/{id}")]` |
| `[FromQuery]` | Из строки запроса | `[HttpGet("api/books?author=...")]` |
| `[FromBody]` | Из тела (JSON) | `[HttpPost("api/books")]` |
| `[FromHeader]` | Из заголовков | `[FromHeader(Name = "X-User-Id")] string userId` |
| `[FromForm]` | Из формы (файлы) | `[FromForm] PhotoDto photo` |

---

### Пример смешанных источников

```csharp
[HttpPost("api/books/{id}/review")]
public IActionResult AddReview([FromRoute] int id, [FromQuery] int rating, [FromBody] string comment)
{
    return Ok($"Книга {id}, оценка {rating}, комментарий: {comment}");
}
```

Запрос:
```
POST /api/books/5/review?rating=9
Content-Type: application/json

"Отличная книга!"
```

Результат:
```
Книга 5, оценка 9, комментарий: Отличная книга!
```

---

## Проверка данных (валидация)

Чтобы сервер не принял мусор, данные проверяются через **атрибуты валидации**.

```csharp
public class BookCreateDto
{
    [Required(ErrorMessage = "Название обязательно")]
    [StringLength(200, MinimumLength = 2, ErrorMessage = "Название должно быть от 2 до 200 символов")]
    public string Title { get; set; } = default!;

    [Required(ErrorMessage = "Автор обязателен")]
    [StringLength(100)]
    public string Author { get; set; } = default!;

    [Range(1800, 2100, ErrorMessage = "Год должен быть от 1800 до 2100")]
    public int Year { get; set; }
}
```

Если клиент отправит неверные данные, ASP.NET Core сам вернёт 400 Bad Request:

```json
{
  "title": "One or more validation errors occurred.",
  "errors": {
    "Title": ["Название обязательно"]
  }
}
```

---

## Возврат данных

Контроллеры возвращают данные в формате **JSON**.

```csharp
[HttpGet("{id}")]
public IActionResult GetBook(int id)
{
    var book = new BookDto
    {
        Id = id,
        Title = "Мастер и Маргарита",
        Author = "Булгаков"
    };

    return Ok(book);
}
```

Ответ:
```json
{
  "id": 1,
  "title": "Мастер и Маргарита",
  "author": "Булгаков"
}
```

---
## Разделение моделей (зачем это нужно)

**Почему нельзя использовать один класс везде?**

Потому что:

1. В базе могут быть поля, которые пользователю видеть нельзя (например, `Password`).
2. На входе может быть меньше данных, чем хранится в базе.
3. Мы можем захотеть поменять формат вывода, не ломая базу.

```csharp
// Что хранится в базе
public class User
{
    public int Id { get; set; }
    public string Email { get; set; } = default!;
    public string PasswordHash { get; set; } = default!;
}

// Что приходит от клиента
public class UserRegisterDto
{
    public string Email { get; set; } = default!;
    public string Password { get; set; } = default!;
}

// Что мы возвращаем клиенту
public class UserDto
{
    public int Id { get; set; }
    public string Email { get; set; } = default!;
}
```

---

## Пример контроллера целиком

```csharp
[ApiController]
[Route("api/books")]
public class BooksController : ControllerBase
{
    private static readonly List<BookDto> _books = new()
    {
        new BookDto { Id = 1, Title = "Мастер и Маргарита", Author = "Булгаков" },
        new BookDto { Id = 2, Title = "Преступление и наказание", Author = "Достоевский" }
    };

    [HttpGet]
    public IActionResult GetAll()
    {
        return Ok(_books);
    }

    [HttpGet("{id}")]
    public IActionResult GetById(int id)
    {
        var book = _books.FirstOrDefault(b => b.Id == id);
        if (book == null)
            return NotFound(new { message = $"Книга с Id={id} не найдена" });

        return Ok(book);
    }

    [HttpPost]
    public IActionResult Create([FromBody] BookCreateDto dto)
    {
        var newBook = new BookDto
        {
            Id = _books.Count + 1,
            Title = dto.Title,
            Author = dto.Author
        };

        _books.Add(newBook);
        return Created($"api/books/{newBook.Id}", newBook);
    }
}
```

---

## Главное

- Модель — это обычный C# класс, который описывает данные.
- `[ApiController]` упрощает жизнь — автоматически проверяет модель и ошибки.
- `[FromBody]`, `[FromRoute]`, `[FromQuery]` указывают, откуда брать данные.
- Атрибуты `[Required]`, `[StringLength]`, `[Range]` помогают проверять введённые значения.
- Возврат данных идёт в формате JSON.
- Делайте отдельные модели для входа и выхода, чтобы не передавать лишние поля.

